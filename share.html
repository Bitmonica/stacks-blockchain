<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<style type="text/css">
pre { white-space: pre-wrap; }
.ef0,.f0 { color: #000000; } .eb0,.b0 { background-color: #000000; }
.ef1,.f1 { color: #AA0000; } .eb1,.b1 { background-color: #AA0000; }
.ef2,.f2 { color: #00AA00; } .eb2,.b2 { background-color: #00AA00; }
.ef3,.f3 { color: #AA5500; } .eb3,.b3 { background-color: #AA5500; }
.ef4,.f4 { color: #0000AA; } .eb4,.b4 { background-color: #0000AA; }
.ef5,.f5 { color: #AA00AA; } .eb5,.b5 { background-color: #AA00AA; }
.ef6,.f6 { color: #00AAAA; } .eb6,.b6 { background-color: #00AAAA; }
.ef7,.f7 { color: #AAAAAA; } .eb7,.b7 { background-color: #AAAAAA; }
.ef8, .f0 > .bold,.bold > .f0 { color: #555555; font-weight: normal; }
.ef9, .f1 > .bold,.bold > .f1 { color: #FF5555; font-weight: normal; }
.ef10,.f2 > .bold,.bold > .f2 { color: #55FF55; font-weight: normal; }
.ef11,.f3 > .bold,.bold > .f3 { color: #FFFF55; font-weight: normal; }
.ef12,.f4 > .bold,.bold > .f4 { color: #5555FF; font-weight: normal; }
.ef13,.f5 > .bold,.bold > .f5 { color: #FF55FF; font-weight: normal; }
.ef14,.f6 > .bold,.bold > .f6 { color: #55FFFF; font-weight: normal; }
.ef15,.f7 > .bold,.bold > .f7 { color: #FFFFFF; font-weight: normal; }
.eb8  { background-color: #555555; }
.eb9  { background-color: #FF5555; }
.eb10 { background-color: #55FF55; }
.eb11 { background-color: #FFFF55; }
.eb12 { background-color: #5555FF; }
.eb13 { background-color: #FF55FF; }
.eb14 { background-color: #55FFFF; }
.eb15 { background-color: #FFFFFF; }
.ef16 { color: #000000; } .eb16 { background-color: #000000; }
.ef17 { color: #00005f; } .eb17 { background-color: #00005f; }
.ef18 { color: #000087; } .eb18 { background-color: #000087; }
.ef19 { color: #0000af; } .eb19 { background-color: #0000af; }
.ef20 { color: #0000d7; } .eb20 { background-color: #0000d7; }
.ef21 { color: #0000ff; } .eb21 { background-color: #0000ff; }
.ef22 { color: #005f00; } .eb22 { background-color: #005f00; }
.ef23 { color: #005f5f; } .eb23 { background-color: #005f5f; }
.ef24 { color: #005f87; } .eb24 { background-color: #005f87; }
.ef25 { color: #005faf; } .eb25 { background-color: #005faf; }
.ef26 { color: #005fd7; } .eb26 { background-color: #005fd7; }
.ef27 { color: #005fff; } .eb27 { background-color: #005fff; }
.ef28 { color: #008700; } .eb28 { background-color: #008700; }
.ef29 { color: #00875f; } .eb29 { background-color: #00875f; }
.ef30 { color: #008787; } .eb30 { background-color: #008787; }
.ef31 { color: #0087af; } .eb31 { background-color: #0087af; }
.ef32 { color: #0087d7; } .eb32 { background-color: #0087d7; }
.ef33 { color: #0087ff; } .eb33 { background-color: #0087ff; }
.ef34 { color: #00af00; } .eb34 { background-color: #00af00; }
.ef35 { color: #00af5f; } .eb35 { background-color: #00af5f; }
.ef36 { color: #00af87; } .eb36 { background-color: #00af87; }
.ef37 { color: #00afaf; } .eb37 { background-color: #00afaf; }
.ef38 { color: #00afd7; } .eb38 { background-color: #00afd7; }
.ef39 { color: #00afff; } .eb39 { background-color: #00afff; }
.ef40 { color: #00d700; } .eb40 { background-color: #00d700; }
.ef41 { color: #00d75f; } .eb41 { background-color: #00d75f; }
.ef42 { color: #00d787; } .eb42 { background-color: #00d787; }
.ef43 { color: #00d7af; } .eb43 { background-color: #00d7af; }
.ef44 { color: #00d7d7; } .eb44 { background-color: #00d7d7; }
.ef45 { color: #00d7ff; } .eb45 { background-color: #00d7ff; }
.ef46 { color: #00ff00; } .eb46 { background-color: #00ff00; }
.ef47 { color: #00ff5f; } .eb47 { background-color: #00ff5f; }
.ef48 { color: #00ff87; } .eb48 { background-color: #00ff87; }
.ef49 { color: #00ffaf; } .eb49 { background-color: #00ffaf; }
.ef50 { color: #00ffd7; } .eb50 { background-color: #00ffd7; }
.ef51 { color: #00ffff; } .eb51 { background-color: #00ffff; }
.ef52 { color: #5f0000; } .eb52 { background-color: #5f0000; }
.ef53 { color: #5f005f; } .eb53 { background-color: #5f005f; }
.ef54 { color: #5f0087; } .eb54 { background-color: #5f0087; }
.ef55 { color: #5f00af; } .eb55 { background-color: #5f00af; }
.ef56 { color: #5f00d7; } .eb56 { background-color: #5f00d7; }
.ef57 { color: #5f00ff; } .eb57 { background-color: #5f00ff; }
.ef58 { color: #5f5f00; } .eb58 { background-color: #5f5f00; }
.ef59 { color: #5f5f5f; } .eb59 { background-color: #5f5f5f; }
.ef60 { color: #5f5f87; } .eb60 { background-color: #5f5f87; }
.ef61 { color: #5f5faf; } .eb61 { background-color: #5f5faf; }
.ef62 { color: #5f5fd7; } .eb62 { background-color: #5f5fd7; }
.ef63 { color: #5f5fff; } .eb63 { background-color: #5f5fff; }
.ef64 { color: #5f8700; } .eb64 { background-color: #5f8700; }
.ef65 { color: #5f875f; } .eb65 { background-color: #5f875f; }
.ef66 { color: #5f8787; } .eb66 { background-color: #5f8787; }
.ef67 { color: #5f87af; } .eb67 { background-color: #5f87af; }
.ef68 { color: #5f87d7; } .eb68 { background-color: #5f87d7; }
.ef69 { color: #5f87ff; } .eb69 { background-color: #5f87ff; }
.ef70 { color: #5faf00; } .eb70 { background-color: #5faf00; }
.ef71 { color: #5faf5f; } .eb71 { background-color: #5faf5f; }
.ef72 { color: #5faf87; } .eb72 { background-color: #5faf87; }
.ef73 { color: #5fafaf; } .eb73 { background-color: #5fafaf; }
.ef74 { color: #5fafd7; } .eb74 { background-color: #5fafd7; }
.ef75 { color: #5fafff; } .eb75 { background-color: #5fafff; }
.ef76 { color: #5fd700; } .eb76 { background-color: #5fd700; }
.ef77 { color: #5fd75f; } .eb77 { background-color: #5fd75f; }
.ef78 { color: #5fd787; } .eb78 { background-color: #5fd787; }
.ef79 { color: #5fd7af; } .eb79 { background-color: #5fd7af; }
.ef80 { color: #5fd7d7; } .eb80 { background-color: #5fd7d7; }
.ef81 { color: #5fd7ff; } .eb81 { background-color: #5fd7ff; }
.ef82 { color: #5fff00; } .eb82 { background-color: #5fff00; }
.ef83 { color: #5fff5f; } .eb83 { background-color: #5fff5f; }
.ef84 { color: #5fff87; } .eb84 { background-color: #5fff87; }
.ef85 { color: #5fffaf; } .eb85 { background-color: #5fffaf; }
.ef86 { color: #5fffd7; } .eb86 { background-color: #5fffd7; }
.ef87 { color: #5fffff; } .eb87 { background-color: #5fffff; }
.ef88 { color: #870000; } .eb88 { background-color: #870000; }
.ef89 { color: #87005f; } .eb89 { background-color: #87005f; }
.ef90 { color: #870087; } .eb90 { background-color: #870087; }
.ef91 { color: #8700af; } .eb91 { background-color: #8700af; }
.ef92 { color: #8700d7; } .eb92 { background-color: #8700d7; }
.ef93 { color: #8700ff; } .eb93 { background-color: #8700ff; }
.ef94 { color: #875f00; } .eb94 { background-color: #875f00; }
.ef95 { color: #875f5f; } .eb95 { background-color: #875f5f; }
.ef96 { color: #875f87; } .eb96 { background-color: #875f87; }
.ef97 { color: #875faf; } .eb97 { background-color: #875faf; }
.ef98 { color: #875fd7; } .eb98 { background-color: #875fd7; }
.ef99 { color: #875fff; } .eb99 { background-color: #875fff; }
.ef100 { color: #878700; } .eb100 { background-color: #878700; }
.ef101 { color: #87875f; } .eb101 { background-color: #87875f; }
.ef102 { color: #878787; } .eb102 { background-color: #878787; }
.ef103 { color: #8787af; } .eb103 { background-color: #8787af; }
.ef104 { color: #8787d7; } .eb104 { background-color: #8787d7; }
.ef105 { color: #8787ff; } .eb105 { background-color: #8787ff; }
.ef106 { color: #87af00; } .eb106 { background-color: #87af00; }
.ef107 { color: #87af5f; } .eb107 { background-color: #87af5f; }
.ef108 { color: #87af87; } .eb108 { background-color: #87af87; }
.ef109 { color: #87afaf; } .eb109 { background-color: #87afaf; }
.ef110 { color: #87afd7; } .eb110 { background-color: #87afd7; }
.ef111 { color: #87afff; } .eb111 { background-color: #87afff; }
.ef112 { color: #87d700; } .eb112 { background-color: #87d700; }
.ef113 { color: #87d75f; } .eb113 { background-color: #87d75f; }
.ef114 { color: #87d787; } .eb114 { background-color: #87d787; }
.ef115 { color: #87d7af; } .eb115 { background-color: #87d7af; }
.ef116 { color: #87d7d7; } .eb116 { background-color: #87d7d7; }
.ef117 { color: #87d7ff; } .eb117 { background-color: #87d7ff; }
.ef118 { color: #87ff00; } .eb118 { background-color: #87ff00; }
.ef119 { color: #87ff5f; } .eb119 { background-color: #87ff5f; }
.ef120 { color: #87ff87; } .eb120 { background-color: #87ff87; }
.ef121 { color: #87ffaf; } .eb121 { background-color: #87ffaf; }
.ef122 { color: #87ffd7; } .eb122 { background-color: #87ffd7; }
.ef123 { color: #87ffff; } .eb123 { background-color: #87ffff; }
.ef124 { color: #af0000; } .eb124 { background-color: #af0000; }
.ef125 { color: #af005f; } .eb125 { background-color: #af005f; }
.ef126 { color: #af0087; } .eb126 { background-color: #af0087; }
.ef127 { color: #af00af; } .eb127 { background-color: #af00af; }
.ef128 { color: #af00d7; } .eb128 { background-color: #af00d7; }
.ef129 { color: #af00ff; } .eb129 { background-color: #af00ff; }
.ef130 { color: #af5f00; } .eb130 { background-color: #af5f00; }
.ef131 { color: #af5f5f; } .eb131 { background-color: #af5f5f; }
.ef132 { color: #af5f87; } .eb132 { background-color: #af5f87; }
.ef133 { color: #af5faf; } .eb133 { background-color: #af5faf; }
.ef134 { color: #af5fd7; } .eb134 { background-color: #af5fd7; }
.ef135 { color: #af5fff; } .eb135 { background-color: #af5fff; }
.ef136 { color: #af8700; } .eb136 { background-color: #af8700; }
.ef137 { color: #af875f; } .eb137 { background-color: #af875f; }
.ef138 { color: #af8787; } .eb138 { background-color: #af8787; }
.ef139 { color: #af87af; } .eb139 { background-color: #af87af; }
.ef140 { color: #af87d7; } .eb140 { background-color: #af87d7; }
.ef141 { color: #af87ff; } .eb141 { background-color: #af87ff; }
.ef142 { color: #afaf00; } .eb142 { background-color: #afaf00; }
.ef143 { color: #afaf5f; } .eb143 { background-color: #afaf5f; }
.ef144 { color: #afaf87; } .eb144 { background-color: #afaf87; }
.ef145 { color: #afafaf; } .eb145 { background-color: #afafaf; }
.ef146 { color: #afafd7; } .eb146 { background-color: #afafd7; }
.ef147 { color: #afafff; } .eb147 { background-color: #afafff; }
.ef148 { color: #afd700; } .eb148 { background-color: #afd700; }
.ef149 { color: #afd75f; } .eb149 { background-color: #afd75f; }
.ef150 { color: #afd787; } .eb150 { background-color: #afd787; }
.ef151 { color: #afd7af; } .eb151 { background-color: #afd7af; }
.ef152 { color: #afd7d7; } .eb152 { background-color: #afd7d7; }
.ef153 { color: #afd7ff; } .eb153 { background-color: #afd7ff; }
.ef154 { color: #afff00; } .eb154 { background-color: #afff00; }
.ef155 { color: #afff5f; } .eb155 { background-color: #afff5f; }
.ef156 { color: #afff87; } .eb156 { background-color: #afff87; }
.ef157 { color: #afffaf; } .eb157 { background-color: #afffaf; }
.ef158 { color: #afffd7; } .eb158 { background-color: #afffd7; }
.ef159 { color: #afffff; } .eb159 { background-color: #afffff; }
.ef160 { color: #d70000; } .eb160 { background-color: #d70000; }
.ef161 { color: #d7005f; } .eb161 { background-color: #d7005f; }
.ef162 { color: #d70087; } .eb162 { background-color: #d70087; }
.ef163 { color: #d700af; } .eb163 { background-color: #d700af; }
.ef164 { color: #d700d7; } .eb164 { background-color: #d700d7; }
.ef165 { color: #d700ff; } .eb165 { background-color: #d700ff; }
.ef166 { color: #d75f00; } .eb166 { background-color: #d75f00; }
.ef167 { color: #d75f5f; } .eb167 { background-color: #d75f5f; }
.ef168 { color: #d75f87; } .eb168 { background-color: #d75f87; }
.ef169 { color: #d75faf; } .eb169 { background-color: #d75faf; }
.ef170 { color: #d75fd7; } .eb170 { background-color: #d75fd7; }
.ef171 { color: #d75fff; } .eb171 { background-color: #d75fff; }
.ef172 { color: #d78700; } .eb172 { background-color: #d78700; }
.ef173 { color: #d7875f; } .eb173 { background-color: #d7875f; }
.ef174 { color: #d78787; } .eb174 { background-color: #d78787; }
.ef175 { color: #d787af; } .eb175 { background-color: #d787af; }
.ef176 { color: #d787d7; } .eb176 { background-color: #d787d7; }
.ef177 { color: #d787ff; } .eb177 { background-color: #d787ff; }
.ef178 { color: #d7af00; } .eb178 { background-color: #d7af00; }
.ef179 { color: #d7af5f; } .eb179 { background-color: #d7af5f; }
.ef180 { color: #d7af87; } .eb180 { background-color: #d7af87; }
.ef181 { color: #d7afaf; } .eb181 { background-color: #d7afaf; }
.ef182 { color: #d7afd7; } .eb182 { background-color: #d7afd7; }
.ef183 { color: #d7afff; } .eb183 { background-color: #d7afff; }
.ef184 { color: #d7d700; } .eb184 { background-color: #d7d700; }
.ef185 { color: #d7d75f; } .eb185 { background-color: #d7d75f; }
.ef186 { color: #d7d787; } .eb186 { background-color: #d7d787; }
.ef187 { color: #d7d7af; } .eb187 { background-color: #d7d7af; }
.ef188 { color: #d7d7d7; } .eb188 { background-color: #d7d7d7; }
.ef189 { color: #d7d7ff; } .eb189 { background-color: #d7d7ff; }
.ef190 { color: #d7ff00; } .eb190 { background-color: #d7ff00; }
.ef191 { color: #d7ff5f; } .eb191 { background-color: #d7ff5f; }
.ef192 { color: #d7ff87; } .eb192 { background-color: #d7ff87; }
.ef193 { color: #d7ffaf; } .eb193 { background-color: #d7ffaf; }
.ef194 { color: #d7ffd7; } .eb194 { background-color: #d7ffd7; }
.ef195 { color: #d7ffff; } .eb195 { background-color: #d7ffff; }
.ef196 { color: #ff0000; } .eb196 { background-color: #ff0000; }
.ef197 { color: #ff005f; } .eb197 { background-color: #ff005f; }
.ef198 { color: #ff0087; } .eb198 { background-color: #ff0087; }
.ef199 { color: #ff00af; } .eb199 { background-color: #ff00af; }
.ef200 { color: #ff00d7; } .eb200 { background-color: #ff00d7; }
.ef201 { color: #ff00ff; } .eb201 { background-color: #ff00ff; }
.ef202 { color: #ff5f00; } .eb202 { background-color: #ff5f00; }
.ef203 { color: #ff5f5f; } .eb203 { background-color: #ff5f5f; }
.ef204 { color: #ff5f87; } .eb204 { background-color: #ff5f87; }
.ef205 { color: #ff5faf; } .eb205 { background-color: #ff5faf; }
.ef206 { color: #ff5fd7; } .eb206 { background-color: #ff5fd7; }
.ef207 { color: #ff5fff; } .eb207 { background-color: #ff5fff; }
.ef208 { color: #ff8700; } .eb208 { background-color: #ff8700; }
.ef209 { color: #ff875f; } .eb209 { background-color: #ff875f; }
.ef210 { color: #ff8787; } .eb210 { background-color: #ff8787; }
.ef211 { color: #ff87af; } .eb211 { background-color: #ff87af; }
.ef212 { color: #ff87d7; } .eb212 { background-color: #ff87d7; }
.ef213 { color: #ff87ff; } .eb213 { background-color: #ff87ff; }
.ef214 { color: #ffaf00; } .eb214 { background-color: #ffaf00; }
.ef215 { color: #ffaf5f; } .eb215 { background-color: #ffaf5f; }
.ef216 { color: #ffaf87; } .eb216 { background-color: #ffaf87; }
.ef217 { color: #ffafaf; } .eb217 { background-color: #ffafaf; }
.ef218 { color: #ffafd7; } .eb218 { background-color: #ffafd7; }
.ef219 { color: #ffafff; } .eb219 { background-color: #ffafff; }
.ef220 { color: #ffd700; } .eb220 { background-color: #ffd700; }
.ef221 { color: #ffd75f; } .eb221 { background-color: #ffd75f; }
.ef222 { color: #ffd787; } .eb222 { background-color: #ffd787; }
.ef223 { color: #ffd7af; } .eb223 { background-color: #ffd7af; }
.ef224 { color: #ffd7d7; } .eb224 { background-color: #ffd7d7; }
.ef225 { color: #ffd7ff; } .eb225 { background-color: #ffd7ff; }
.ef226 { color: #ffff00; } .eb226 { background-color: #ffff00; }
.ef227 { color: #ffff5f; } .eb227 { background-color: #ffff5f; }
.ef228 { color: #ffff87; } .eb228 { background-color: #ffff87; }
.ef229 { color: #ffffaf; } .eb229 { background-color: #ffffaf; }
.ef230 { color: #ffffd7; } .eb230 { background-color: #ffffd7; }
.ef231 { color: #ffffff; } .eb231 { background-color: #ffffff; }
.ef232 { color: #080808; } .eb232 { background-color: #080808; }
.ef233 { color: #121212; } .eb233 { background-color: #121212; }
.ef234 { color: #1c1c1c; } .eb234 { background-color: #1c1c1c; }
.ef235 { color: #262626; } .eb235 { background-color: #262626; }
.ef236 { color: #303030; } .eb236 { background-color: #303030; }
.ef237 { color: #3a3a3a; } .eb237 { background-color: #3a3a3a; }
.ef238 { color: #444444; } .eb238 { background-color: #444444; }
.ef239 { color: #4e4e4e; } .eb239 { background-color: #4e4e4e; }
.ef240 { color: #585858; } .eb240 { background-color: #585858; }
.ef241 { color: #626262; } .eb241 { background-color: #626262; }
.ef242 { color: #6c6c6c; } .eb242 { background-color: #6c6c6c; }
.ef243 { color: #767676; } .eb243 { background-color: #767676; }
.ef244 { color: #808080; } .eb244 { background-color: #808080; }
.ef245 { color: #8a8a8a; } .eb245 { background-color: #8a8a8a; }
.ef246 { color: #949494; } .eb246 { background-color: #949494; }
.ef247 { color: #9e9e9e; } .eb247 { background-color: #9e9e9e; }
.ef248 { color: #a8a8a8; } .eb248 { background-color: #a8a8a8; }
.ef249 { color: #b2b2b2; } .eb249 { background-color: #b2b2b2; }
.ef250 { color: #bcbcbc; } .eb250 { background-color: #bcbcbc; }
.ef251 { color: #c6c6c6; } .eb251 { background-color: #c6c6c6; }
.ef252 { color: #d0d0d0; } .eb252 { background-color: #d0d0d0; }
.ef253 { color: #dadada; } .eb253 { background-color: #dadada; }
.ef254 { color: #e4e4e4; } .eb254 { background-color: #e4e4e4; }
.ef255 { color: #eeeeee; } .eb255 { background-color: #eeeeee; }

.f9 { color: #000000; }
.b9 { background-color: #FFFFFF; }
.f9 > .bold,.bold > .f9, body.f9 > pre > .bold {
  /* Bold is heavy black on white, or bright white
     depending on the default background */
  color: #000000;
  font-weight: bold;
}
.reverse {
  /* CSS does not support swapping fg and bg colours unfortunately,
     so just hardcode something that will look OK on all backgrounds. */
  color: #000000; background-color: #AAAAAA;
}
.underline { text-decoration: underline; }
.line-through { text-decoration: line-through; }
.blink { text-decoration: blink; }

/* Avoid pixels between adjacent span elements.
   Note this only works for lines less than 80 chars
   where we close span elements on the same line.
span { display: inline-block; }
*/
</style>
</head>

<body class="f9 b9">
<pre>
<span class="bold">diff --git a/src/chainstate/coordinator/mod.rs b/src/chainstate/coordinator/mod.rs
index 95dae303f..2a11400c1 100644</span>
<span class="bold">--- a/src/chainstate/coordinator/mod.rs</span>
<span class="bold">+++ b/src/chainstate/coordinator/mod.rs</span>
<span class="f6">@@ -16,6 +16,7 @@</span>

use std::collections::{HashMap, HashSet, VecDeque};
use std::convert::{TryFrom, TryInto};
<span class="f2">use std::path::PathBuf;</span>
use std::sync::mpsc::SyncSender;
use std::time::Duration;

<span class="f6">@@ -51,6 +52,7 @@</span> use vm::{
    Value,
};

<span class="f2">use crate::cost_estimates::{CostEstimator, PessimisticEstimator};</span>
use crate::types::chainstate::{
    BlockHeaderHash, BurnchainHeaderHash, PoxId, SortitionId, StacksAddress, StacksBlockHeader,
    StacksBlockId,
<span class="f6">@@ -156,6 +158,7 @@</span> pub struct ChainsCoordinator&lt;
    burnchain: Burnchain,
    attachments_tx: SyncSender&lt;HashSet&lt;AttachmentInstance&gt;&gt;,
    dispatcher: Option&lt;&amp;'a T&gt;,
    <span class="f2">estimator: Option&lt;PessimisticEstimator&gt;,</span>
    reward_set_provider: R,
    notifier: N,
    atlas_config: AtlasConfig,
<span class="f6">@@ -278,6 +281,10 @@</span> impl&lt;'a, T: BlockEventDispatcher&gt;
            sortitions_processed,
        };

        <span class="f2">let mut estimator_path = PathBuf::from(&amp;chain_state_db.root_path);</span>
<span class="f2">        estimator_path.push(&quot;cost_estimator.sqlite&quot;);</span>
<span class="f2">        let estimator = PessimisticEstimator::open(&amp;estimator_path).expect(&quot;SQLite Failure&quot;);</span>

        let mut inst = ChainsCoordinator {
            canonical_chain_tip: None,
            canonical_sortition_tip: Some(canonical_sortition_tip),
<span class="f6">@@ -290,6 +297,7 @@</span> impl&lt;'a, T: BlockEventDispatcher&gt;
            dispatcher: Some(dispatcher),
            notifier: arc_notices,
            reward_set_provider: OnChainRewardSetProvider(),
            <span class="f2">estimator: Some(estimator),</span>
            atlas_config,
        };

<span class="f6">@@ -354,6 +362,7 @@</span> impl&lt;'a, T: BlockEventDispatcher, U: RewardSetProvider&gt; ChainsCoordinator&lt;'a, T,
            sortition_db,
            burnchain,
            dispatcher: None,
            <span class="f2">estimator: None,</span>
            reward_set_provider,
            notifier: (),
            attachments_tx,
<span class="f6">@@ -728,6 +737,20 @@</span> impl&lt;'a, T: BlockEventDispatcher, N: CoordinatorNotices, U: RewardSetProvider&gt;
                        };
                    }

                    <span class="f2">if let Some(ref mut estimator) = self.estimator {</span>
<span class="f2">                        let metadata = &amp;block_receipt.header;</span>
<span class="f2">                        let block: StacksBlock = {</span>
<span class="f2">                            let block_path = StacksChainState::get_block_path(</span>
<span class="f2">                                &amp;self.chain_state_db.blocks_path,</span>
<span class="f2">                                &amp;metadata.consensus_hash,</span>
<span class="f2">                                &amp;block_hash,</span>
<span class="f2">                            )</span>
<span class="f2">                            .unwrap();</span>
<span class="f2">                            StacksChainState::consensus_load(&amp;block_path).unwrap()</span>
<span class="f2">                        };</span>
<span class="f2">                        estimator.notify_block(&amp;block, &amp;block_receipt.tx_receipts);</span>
<span class="f2">                    }</span>

                    if let Some(dispatcher) = self.dispatcher {
                        let metadata = &amp;block_receipt.header;
                        let winner_txid = SortitionDB::get_block_snapshot_for_winning_stacks_block(
<span class="f6">@@ -755,6 +778,7 @@</span> impl&lt;'a, T: BlockEventDispatcher, N: CoordinatorNotices, U: RewardSetProvider&gt;
                            .chain_state_db
                            .get_parent(&amp;stacks_block)
                            .expect(&quot;BUG: failed to get parent for processed block&quot;);

                        dispatcher.announce_block(
                            block,
                            block_receipt.header,
<span class="bold">diff --git a/src/cost_estimates/mod.rs b/src/cost_estimates/mod.rs</span>
<span class="bold">new file mode 100644</span>
<span class="bold">index 000000000..1ddaf4a33</span>
<span class="bold">--- /dev/null</span>
<span class="bold">+++ b/src/cost_estimates/mod.rs</span>
<span class="f6">@@ -0,0 +1,118 @@</span>
<span class="f2">use std::collections::HashMap;</span>
<span class="f2">use std::iter::FromIterator;</span>
<span class="f2">use std::{error::Error, fmt::Display};</span>

<span class="f2">use chainstate::stacks::events::{StacksTransactionReceipt, TransactionOrigin};</span>
<span class="f2">use chainstate::stacks::{StacksBlock, TransactionPayload};</span>
<span class="f2">use vm::costs::ExecutionCost;</span>

<span class="f2">use crate::burnchains::Txid;</span>

<span class="f2">pub mod pessimistic;</span>
<span class="f2">pub use self::pessimistic::PessimisticEstimator;</span>

<span class="f2">pub trait CostEstimator {</span>
<span class="f2">    /// This method is invoked by the `stacks-node` to update the cost estimator with a new</span>
<span class="f2">    ///  cost measurement. The given `tx` had a measured cost of `actual_cost`.</span>
<span class="f2">    fn notify_event(</span>
<span class="f2">        &amp;mut self,</span>
<span class="f2">        tx: &amp;TransactionPayload,</span>
<span class="f2">        actual_cost: &amp;ExecutionCost,</span>
<span class="f2">    ) -&gt; Result&lt;(), EstimatorError&gt;;</span>
<span class="f2">    /// This method is used by a stacks-node to obtain an estimate for a given transaction payload.</span>
<span class="f2">    /// If the estimator cannot provide an accurate estimate for a given payload, it should return</span>
<span class="f2">    /// `EstimatorError::NoEstimateAvailable`</span>
<span class="f2">    fn estimate_cost(&amp;self, tx: &amp;TransactionPayload) -&gt; Result&lt;ExecutionCost, EstimatorError&gt;;</span>
<span class="f2">    fn notify_block(&amp;mut self, block: &amp;StacksBlock, receipts: &amp;[StacksTransactionReceipt]) {</span>
<span class="f2">        // create a Map from txid -&gt; index in block</span>
<span class="f2">        let tx_index: HashMap&lt;Txid, usize&gt; = HashMap::from_iter(</span>
<span class="f2">            block</span>
<span class="f2">                .txs</span>
<span class="f2">                .iter()</span>
<span class="f2">                .enumerate()</span>
<span class="f2">                .map(|(tx_ix, tx)| (tx.txid(), tx_ix)),</span>
<span class="f2">        );</span>
<span class="f2">        // iterate over receipts, and for all the tx receipts, notify the event</span>
<span class="f2">        for current_receipt in receipts.iter() {</span>
<span class="f2">            let current_txid = match current_receipt.transaction {</span>
<span class="f2">                TransactionOrigin::Burn(_) =&gt; continue,</span>
<span class="f2">                TransactionOrigin::Stacks(ref tx) =&gt; tx.txid(),</span>
<span class="f2">            };</span>
<span class="f2">            let tx_payload = match tx_index.get(&amp;current_txid) {</span>
<span class="f2">                Some(block_index) =&gt; &amp;block.txs[*block_index].payload,</span>
<span class="f2">                None =&gt; continue,</span>
<span class="f2">            };</span>

<span class="f2">            if let Err(e) = self.notify_event(tx_payload, &amp;current_receipt.execution_cost) {</span>
<span class="f2">                info!(&quot;CostEstimator failed to process event&quot;;</span>
<span class="f2">                      &quot;txid&quot; =&gt; %current_txid,</span>
<span class="f2">                      &quot;stacks_block&quot; =&gt; %block.header.block_hash(),</span>
<span class="f2">                      &quot;error&quot; =&gt; %e,</span>
<span class="f2">                      &quot;execution_cost&quot; =&gt; %current_receipt.execution_cost);</span>
<span class="f2">            }</span>
<span class="f2">        }</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">#[derive(Debug)]</span>
<span class="f2">pub enum EstimatorError {</span>
<span class="f2">    NoEstimateAvailable,</span>
<span class="f2">}</span>

<span class="f2">impl Error for EstimatorError {</span>
<span class="f2">    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {</span>
<span class="f2">        None</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">impl Display for EstimatorError {</span>
<span class="f2">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {</span>
<span class="f2">        match self {</span>
<span class="f2">            EstimatorError::NoEstimateAvailable =&gt; {</span>
<span class="f2">                write!(f, &quot;No estimate available for the provided payload.&quot;)</span>
<span class="f2">            }</span>
<span class="f2">        }</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">struct LogEstimator;</span>

<span class="f2">impl CostEstimator for LogEstimator {</span>
<span class="f2">    fn notify_event(</span>
<span class="f2">        &amp;mut self,</span>
<span class="f2">        tx: &amp;TransactionPayload,</span>
<span class="f2">        actual_cost: &amp;ExecutionCost,</span>
<span class="f2">    ) -&gt; Result&lt;(), EstimatorError&gt; {</span>
<span class="f2">        let (tx_descriptor, arg_size) = match tx {</span>
<span class="f2">            TransactionPayload::TokenTransfer(..) =&gt; (&quot;stx-transfer&quot;.to_string(), 1),</span>
<span class="f2">            TransactionPayload::ContractCall(cc) =&gt; (</span>
<span class="f2">                format!(&quot;cc:{}.{}&quot;, cc.contract_name, cc.function_name),</span>
<span class="f2">                cc.function_args</span>
<span class="f2">                    .iter()</span>
<span class="f2">                    .fold(0, |acc, value| acc + value.size() as usize),</span>
<span class="f2">            ),</span>
<span class="f2">            TransactionPayload::SmartContract(sc) =&gt; {</span>
<span class="f2">                (&quot;contract-publish&quot;.to_string(), sc.code_body.len())</span>
<span class="f2">            }</span>
<span class="f2">            // ignore poison microblock and coinbase events</span>
<span class="f2">            TransactionPayload::PoisonMicroblock(_, _) | TransactionPayload::Coinbase(_) =&gt; {</span>
<span class="f2">                return Ok(())</span>
<span class="f2">            }</span>
<span class="f2">        };</span>
<span class="f2">        info!(</span>
<span class="f2">            &quot;{}, {}, {}, {}, {}, {}, {}&quot;,</span>
<span class="f2">            tx_descriptor,</span>
<span class="f2">            arg_size,</span>
<span class="f2">            actual_cost.runtime,</span>
<span class="f2">            actual_cost.write_count,</span>
<span class="f2">            actual_cost.write_length,</span>
<span class="f2">            actual_cost.read_length,</span>
<span class="f2">            actual_cost.read_count</span>
<span class="f2">        );</span>
<span class="f2">        Ok(())</span>
<span class="f2">    }</span>

<span class="f2">    fn estimate_cost(&amp;self, _tx: &amp;TransactionPayload) -&gt; Result&lt;ExecutionCost, EstimatorError&gt; {</span>
<span class="f2">        todo!()</span>
<span class="f2">    }</span>
<span class="f2">}</span>
<span class="bold">diff --git a/src/cost_estimates/pessimistic.rs b/src/cost_estimates/pessimistic.rs</span>
<span class="bold">new file mode 100644</span>
<span class="bold">index 000000000..d220853a9</span>
<span class="bold">--- /dev/null</span>
<span class="bold">+++ b/src/cost_estimates/pessimistic.rs</span>
<span class="f6">@@ -0,0 +1,262 @@</span>
<span class="f2">use std::convert::TryFrom;</span>
<span class="f2">use std::{iter::FromIterator, path::Path};</span>

<span class="f2">use rusqlite::{</span>
<span class="f2">    types::{FromSql, FromSqlError},</span>
<span class="f2">    Connection, Error as SqliteError, OptionalExtension, ToSql,</span>
<span class="f2">};</span>
<span class="f2">use serde_json::Value as JsonValue;</span>

<span class="f2">use chainstate::stacks::TransactionPayload;</span>
<span class="f2">use util::db::u64_to_sql;</span>
<span class="f2">use vm::costs::ExecutionCost;</span>

<span class="f2">use core::BLOCK_LIMIT_MAINNET;</span>

<span class="f2">use super::{CostEstimator, EstimatorError};</span>

<span class="f2">pub struct PessimisticEstimator {</span>
<span class="f2">    db: Connection,</span>
<span class="f2">    log_error: bool,</span>
<span class="f2">}</span>

<span class="f2">#[derive(Debug)]</span>
<span class="f2">struct Samples {</span>
<span class="f2">    items: Vec&lt;u64&gt;,</span>
<span class="f2">}</span>

<span class="f2">const SAMPLE_SIZE: usize = 10;</span>

<span class="f2">iterable_enum!(CostField {</span>
<span class="f2">    RuntimeCost,</span>
<span class="f2">    WriteLength,</span>
<span class="f2">    WriteCount,</span>
<span class="f2">    ReadLength,</span>
<span class="f2">    ReadCount,</span>
<span class="f2">});</span>

<span class="f2">impl CostField {</span>
<span class="f2">    /// Select `self` out of the given ExecutionCost</span>
<span class="f2">    fn select_key(&amp;self, from_cost: &amp;ExecutionCost) -&gt; u64 {</span>
<span class="f2">        match self {</span>
<span class="f2">            CostField::RuntimeCost =&gt; from_cost.runtime,</span>
<span class="f2">            CostField::WriteLength =&gt; from_cost.write_length,</span>
<span class="f2">            CostField::WriteCount =&gt; from_cost.write_count,</span>
<span class="f2">            CostField::ReadLength =&gt; from_cost.read_length,</span>
<span class="f2">            CostField::ReadCount =&gt; from_cost.read_count,</span>
<span class="f2">        }</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">impl std::fmt::Display for CostField {</span>
<span class="f2">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {</span>
<span class="f2">        match self {</span>
<span class="f2">            CostField::RuntimeCost =&gt; write!(f, &quot;runtime&quot;),</span>
<span class="f2">            CostField::WriteLength =&gt; write!(f, &quot;write-length&quot;),</span>
<span class="f2">            CostField::WriteCount =&gt; write!(f, &quot;write-count&quot;),</span>
<span class="f2">            CostField::ReadLength =&gt; write!(f, &quot;read-length&quot;),</span>
<span class="f2">            CostField::ReadCount =&gt; write!(f, &quot;read-count&quot;),</span>
<span class="f2">        }</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">impl FromSql for Samples {</span>
<span class="f2">    fn column_result(</span>
<span class="f2">        sql_value: rusqlite::types::ValueRef&lt;'_&gt;,</span>
<span class="f2">    ) -&gt; rusqlite::types::FromSqlResult&lt;Self&gt; {</span>
<span class="f2">        let json_value = JsonValue::column_result(sql_value)?;</span>
<span class="f2">        let items = serde_json::from_value(json_value).map_err(|_e| {</span>
<span class="f2">            error!(&quot;Failed to parse PessimisticEstimator sample from SQL&quot;);</span>
<span class="f2">            FromSqlError::InvalidType</span>
<span class="f2">        })?;</span>
<span class="f2">        Ok(Samples { items })</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">impl Samples {</span>
<span class="f2">    fn to_json(&amp;self) -&gt; JsonValue {</span>
<span class="f2">        JsonValue::from(self.items.as_slice())</span>
<span class="f2">    }</span>

<span class="f2">    /// Add a new sample to this struct. The pessimistic sampler only adds to the sample set</span>
<span class="f2">    ///  if the sample set is less than SAMPLE_SIZE or the new sample is greater than the current min.
    /// Boolean return indicates whether or not the sample was included.</span>
<span class="f2">    fn update_with(&amp;mut self, sample: u64) -&gt; bool {</span>
<span class="f2">        if self.items.len() &lt; SAMPLE_SIZE {</span>
<span class="f2">            self.items.push(sample);</span>
<span class="f2">            return true;</span>
<span class="f2">        }</span>

<span class="f2">        let (min_index, min_val) = match self</span>
<span class="f2">            .items</span>
<span class="f2">            .iter()</span>
<span class="f2">            .enumerate()</span>
<span class="f2">            .min_by_key(|(_i, value)| *value)</span>
<span class="f2">        {</span>
<span class="f2">            None =&gt; {</span>
<span class="f2">                unreachable!(&quot;Should find minimum if len() &gt;= SAMPLE_SIZE&quot;);</span>
<span class="f2">            }</span>
<span class="f2">            Some(x) =&gt; x,</span>
<span class="f2">        };</span>

<span class="f2">        if sample &gt; *min_val {</span>
<span class="f2">            self.items[min_index] = sample;</span>
<span class="f2">            return true;</span>
<span class="f2">        }</span>

<span class="f2">        return false;</span>
<span class="f2">    }</span>

<span class="f2">    /// Return the integer mean of the sample</span>
<span class="f2">    fn mean(&amp;self) -&gt; u64 {</span>
<span class="f2">        let item_len = self.items.len() as u64;</span>
<span class="f2">        self.items</span>
<span class="f2">            .iter()</span>
<span class="f2">            .fold(0, |acc, item| acc + (*item / item_len))</span>
<span class="f2">    }</span>

<span class="f2">    fn flush_sqlite(&amp;self, conn: &amp;Connection, identifier: &amp;str) {</span>
<span class="f2">        let sql = &quot;INSERT OR REPLACE INTO pessimistic_estimator</span>
<span class="f2">                     (estimate_key, current_value, samples) VALUES (?, ?, ?)&quot;;</span>
<span class="f2">        let current_value = u64_to_sql(self.mean()).unwrap_or_else(|_| i64::max_value());</span>
<span class="f2">        conn.execute(</span>
<span class="f2">            sql,</span>
<span class="f2">            rusqlite::params![identifier, current_value, self.to_json()],</span>
<span class="f2">        )</span>
<span class="f2">        .expect(&quot;SQLite failure&quot;);</span>
<span class="f2">    }</span>

<span class="f2">    fn get_sqlite(conn: &amp;Connection, identifier: &amp;str) -&gt; Samples {</span>
<span class="f2">        let sql = &quot;SELECT samples FROM pessimistic_estimator WHERE estimate_key = ?&quot;;</span>
<span class="f2">        conn.query_row(sql, &amp;[identifier], |row| row.get(0))</span>
<span class="f2">            .optional()</span>
<span class="f2">            .expect(&quot;SQLite failure&quot;)</span>
<span class="f2">            .unwrap_or_else(|| Samples { items: vec![] })</span>
<span class="f2">    }</span>

<span class="f2">    fn get_estimate_sqlite(conn: &amp;Connection, identifier: &amp;str) -&gt; Option&lt;u64&gt; {</span>
<span class="f2">        let sql = &quot;SELECT current_value FROM pessimistic_estimator WHERE estimate_key = ?&quot;;</span>
<span class="f2">        conn.query_row::&lt;i64, _, _&gt;(sql, &amp;[identifier], |row| row.get(0))</span>
<span class="f2">            .optional()</span>
<span class="f2">            .expect(&quot;SQLite failure&quot;)</span>
<span class="f2">            .map(|x_i64| {</span>
<span class="f2">                u64::try_from(x_i64).expect(&quot;DB corrupt, non-u64-valid estimate was stored&quot;)</span>
<span class="f2">            })</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">impl PessimisticEstimator {</span>
<span class="f2">    /// Open a pessimistic estimator at the given db path. Creates if not existent.</span>
<span class="f2">    pub fn open(p: &amp;Path) -&gt; Result&lt;PessimisticEstimator, SqliteError&gt; {</span>
<span class="f2">        let db = Connection::open_with_flags(p, rusqlite::OpenFlags::SQLITE_OPEN_READ_WRITE)</span>
<span class="f2">            .or_else(|e| {</span>
<span class="f2">                if let SqliteError::SqliteFailure(ref internal, _) = e {</span>
<span class="f2">                    if let rusqlite::ErrorCode::CannotOpen = internal.code {</span>
<span class="f2">                        let db = Connection::open(p)?;</span>
<span class="f2">                        PessimisticEstimator::instantiate_db(&amp;db)?;</span>
<span class="f2">                        Ok(db)</span>
<span class="f2">                    } else {</span>
<span class="f2">                        Err(e)</span>
<span class="f2">                    }</span>
<span class="f2">                } else {</span>
<span class="f2">                    Err(e)</span>
<span class="f2">                }</span>
<span class="f2">            })?;</span>
<span class="f2">        Ok(PessimisticEstimator {</span>
<span class="f2">            db,</span>
<span class="f2">            log_error: true,</span>
<span class="f2">        })</span>
<span class="f2">    }</span>

<span class="f2">    fn instantiate_db(c: &amp;Connection) -&gt; Result&lt;(), SqliteError&gt; {</span>
<span class="f2">        let sql = &quot;CREATE TABLE pessimistic_estimator (</span>
<span class="f2">           estimate_key TEXT PRIMARY KEY,</span>
<span class="f2">           current_value NUMBER,</span>
<span class="f2">           samples TEXT</span>
<span class="f2">        )&quot;;</span>
<span class="f2">        c.execute(sql, rusqlite::NO_PARAMS)?;</span>
<span class="f2">        Ok(())</span>
<span class="f2">    }</span>

<span class="f2">    fn get_estimate_key(tx: &amp;TransactionPayload, field: &amp;CostField) -&gt; String {</span>
<span class="f2">        let tx_descriptor = match tx {</span>
<span class="f2">            TransactionPayload::TokenTransfer(..) =&gt; &quot;stx-transfer&quot;.to_string(),</span>
<span class="f2">            TransactionPayload::ContractCall(cc) =&gt; {</span>
<span class="f2">                format!(&quot;cc:{}.{}&quot;, cc.contract_name, cc.function_name)</span>
<span class="f2">            }</span>
<span class="f2">            TransactionPayload::SmartContract(_sc) =&gt; &quot;contract-publish&quot;.to_string(),</span>
<span class="f2">            TransactionPayload::PoisonMicroblock(_, _) =&gt; &quot;poison-ublock&quot;.to_string(),</span>
<span class="f2">            TransactionPayload::Coinbase(_) =&gt; &quot;coinbase&quot;.to_string(),</span>
<span class="f2">        };</span>

<span class="f2">        format!(&quot;{}:{}&quot;, &amp;tx_descriptor, field)</span>
<span class="f2">    }</span>
<span class="f2">}</span>

<span class="f2">impl CostEstimator for PessimisticEstimator {</span>
<span class="f2">    fn notify_event(</span>
<span class="f2">        &amp;mut self,</span>
<span class="f2">        tx: &amp;TransactionPayload,</span>
<span class="f2">        actual_cost: &amp;ExecutionCost,</span>
<span class="f2">    ) -&gt; Result&lt;(), EstimatorError&gt; {</span>
<span class="f2">        if self.log_error {</span>
<span class="f2">            // only log the estimate error if an estimate could be constructed</span>
<span class="f2">            if let Ok(estimated_cost) = self.estimate_cost(tx) {</span>
<span class="f2">                let estimated_scalar = estimated_cost.proportion_dot_product(&amp;BLOCK_LIMIT_MAINNET);</span>
<span class="f2">                let actual_scalar = actual_cost.proportion_dot_product(&amp;BLOCK_LIMIT_MAINNET);</span>
<span class="f2">                info!(&quot;PessimisticEstimator received event&quot;;</span>
<span class="f2">                      &quot;key&quot; =&gt; %PessimisticEstimator::get_estimate_key(tx, &amp;CostField::RuntimeCost),</span>
<span class="f2">                      &quot;estimate&quot; =&gt; estimated_scalar,</span>
<span class="f2">                      &quot;actual&quot; =&gt; actual_scalar,</span>
<span class="f2">                      &quot;estimate_err&quot; =&gt; (estimated_scalar as i64 - actual_scalar as i64),</span>
<span class="f2">                      &quot;estimate_err_pct&quot; =&gt; (estimated_scalar as i64 - actual_scalar as i64)/(cmp::max(1, actual_scalar as i64)),);
            }</span>
<span class="f2">        }</span>

<span class="f2">        for field in CostField::ALL.iter() {</span>
<span class="f2">            let key = PessimisticEstimator::get_estimate_key(tx, field);</span>
<span class="f2">            let field_cost = field.select_key(actual_cost);</span>
<span class="f2">            let mut current_sample = Samples::get_sqlite(&amp;self.db, &amp;key);</span>
<span class="f2">            current_sample.update_with(field_cost);</span>
<span class="f2">            current_sample.flush_sqlite(&amp;self.db, &amp;key);</span>
<span class="f2">        }</span>

<span class="f2">        Ok(())</span>
<span class="f2">    }</span>

<span class="f2">    fn estimate_cost(&amp;self, tx: &amp;TransactionPayload) -&gt; Result&lt;ExecutionCost, EstimatorError&gt; {</span>
<span class="f2">        let runtime = Samples::get_estimate_sqlite(</span>
<span class="f2">            &amp;self.db,</span>
<span class="f2">            &amp;PessimisticEstimator::get_estimate_key(tx, &amp;CostField::RuntimeCost),</span>
<span class="f2">        )</span>
<span class="f2">        .ok_or_else(|| EstimatorError::NoEstimateAvailable)?;</span>
<span class="f2">        let read_count = Samples::get_estimate_sqlite(</span>
<span class="f2">            &amp;self.db,</span>
<span class="f2">            &amp;PessimisticEstimator::get_estimate_key(tx, &amp;CostField::ReadCount),</span>
<span class="f2">        )</span>
<span class="f2">        .ok_or_else(|| EstimatorError::NoEstimateAvailable)?;</span>
<span class="f2">        let read_length = Samples::get_estimate_sqlite(</span>
<span class="f2">            &amp;self.db,</span>
<span class="f2">            &amp;PessimisticEstimator::get_estimate_key(tx, &amp;CostField::ReadLength),</span>
<span class="f2">        )</span>
<span class="f2">        .ok_or_else(|| EstimatorError::NoEstimateAvailable)?;</span>
<span class="f2">        let write_count = Samples::get_estimate_sqlite(</span>
<span class="f2">            &amp;self.db,</span>
<span class="f2">            &amp;PessimisticEstimator::get_estimate_key(tx, &amp;CostField::WriteCount),</span>
<span class="f2">        )</span>
<span class="f2">        .ok_or_else(|| EstimatorError::NoEstimateAvailable)?;</span>
<span class="f2">        let write_length = Samples::get_estimate_sqlite(</span>
<span class="f2">            &amp;self.db,</span>
<span class="f2">            &amp;PessimisticEstimator::get_estimate_key(tx, &amp;CostField::WriteLength),</span>
<span class="f2">        )</span>
<span class="f2">        .ok_or_else(|| EstimatorError::NoEstimateAvailable)?;</span>

<span class="f2">        Ok(ExecutionCost {</span>
<span class="f2">            runtime,</span>
<span class="f2">            read_count,</span>
<span class="f2">            read_length,</span>
<span class="f2">            write_count,</span>
<span class="f2">            write_length,</span>
<span class="f2">        })</span>
<span class="f2">    }</span>
<span class="f2">}</span>
<span class="bold">diff --git a/src/lib.rs b/src/lib.rs</span>
<span class="bold">index 0e77b65f5..a8b19d758 100644</span>
<span class="bold">--- a/src/lib.rs</span>
<span class="bold">+++ b/src/lib.rs</span>
<span class="f6">@@ -95,6 +95,8 @@</span> pub mod clarity;
pub mod monitoring;
pub mod types;

<span class="f2">pub mod cost_estimates;</span>

// set via _compile-time_ envars
const GIT_BRANCH: Option&lt;&amp;'static str&gt; = option_env!(&quot;GIT_BRANCH&quot;);
const GIT_COMMIT: Option&lt;&amp;'static str&gt; = option_env!(&quot;GIT_COMMIT&quot;);
<span class="bold">diff --git a/src/util/macros.rs b/src/util/macros.rs</span>
<span class="bold">index 61fc85b9d..1cab333e0 100644</span>
<span class="bold">--- a/src/util/macros.rs</span>
<span class="bold">+++ b/src/util/macros.rs</span>
<span class="f6">@@ -21,6 +21,21 @@</span> pub fn is_big_endian() -&gt; bool {
    u32::from_be(0x1Au32) == 0x1Au32
}

<span class="f2">/// Define an iterable enum: an enum where each variant is an atomic</span>
<span class="f2">/// type (i.e., has no paramters), and the variants can be iterated over</span>
<span class="f2">/// with an Enum::ALL const</span>
<span class="f2">macro_rules! iterable_enum {</span>
<span class="f2">    ($Name:ident { $($Variant:ident,)* }) =&gt;</span>
<span class="f2">    {</span>
<span class="f2">        pub enum $Name {</span>
<span class="f2">            $($Variant),*,</span>
<span class="f2">        }</span>
<span class="f2">        impl $Name {</span>
<span class="f2">            pub const ALL: &amp;'static [$Name] = &amp;[$($Name::$Variant),*];</span>
<span class="f2">        }</span>
<span class="f2">    }</span>
<span class="f2">}</span>

/// Define a &quot;named&quot; enum, i.e., each variant corresponds
///  to a string literal, with a 1-1 mapping. You get EnumType::lookup_by_name
///  and EnumType.get_name() for free.
<span class="bold">diff --git a/src/vm/costs/mod.rs b/src/vm/costs/mod.rs</span>
<span class="bold">index 38d8e60c0..8893a1b87 100644</span>
<span class="bold">--- a/src/vm/costs/mod.rs</span>
<span class="bold">+++ b/src/vm/costs/mod.rs</span>
<span class="f6">@@ -997,6 +997,21 @@</span> impl ExecutionCost {
        .clone()
    }

    <span class="f2">/// Returns the dot product of this execution cost with 1000/block_limit</span>
<span class="f2">    /// This provides a scalar value representing the cumulative consumption</span>
<span class="f2">    /// of `self` in the provided block_limit.</span>
<span class="f2">    pub fn proportion_dot_product(&amp;self, block_limit: &amp;ExecutionCost) -&gt; u64 {</span>
<span class="f2">        [</span>
<span class="f2">            self.runtime / cmp::max(1, block_limit.runtime / 1000),</span>
<span class="f2">            self.write_length / cmp::max(1, block_limit.write_length / 1000),</span>
<span class="f2">            self.write_count / cmp::max(1, block_limit.write_count / 1000),</span>
<span class="f2">            self.read_length / cmp::max(1, block_limit.read_length / 1000),</span>
<span class="f2">            self.read_count / cmp::max(1, block_limit.read_count / 1000),</span>
<span class="f2">        ]</span>
<span class="f2">        .iter()</span>
<span class="f2">        .fold(0, |acc, dim| acc.checked_add(*dim).unwrap_or(u64::MAX))</span>
<span class="f2">    }</span>

    pub fn max_value() -&gt; ExecutionCost {
        Self {
            runtime: u64::MAX,
</pre>
</body>
</html>
